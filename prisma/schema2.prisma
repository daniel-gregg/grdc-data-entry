// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// All people accessing any functionality of Affine have a user account
// Users are only the human interface to Affine reporting and data entry
// So, Users without an organisation can only view reports that they are given access to
// All other functionality is nested within an organisation:
//   * requesting module completion
//   * adding suppliers
//   * creating reports
//   * requesting viewers for reports
//   * etc. 
// Users must be a member of an organisation to undertake these activities

model User {
  id String  @id @unique @default(uuid())
  createdAt DateTime? @default(now())
  updatedAt DateTime? @default(now())
  email String @unique

  //details of user - make optional for completion in profile
  firstName String?
  lastName String?

  //user has reports they can view
  reportsView Report[] @relation(name: "reportsViewer")

  //user is the author of reports
  reportsAuthor Report[] @relation(name: "AuthorId")

  //Map to organisation as userOrgId
  organisationId Organisation? @relation(fields: [id], references: [id], map: "orgUserId", name: "orgUserId")
  
  //Map to organisation as userAdminId
  orgAdminId Organisation? @relation(fields: [id], references: [id], map: "orgAdminId", name: "orgAdminId")
}

// Organisations are the key centralising component of Affine. Organisations create reports, request data inputs, aggregate results, etc.
// Orgs can be self-referential - they can request data inputs from themselves. So, for example, a farm business can register
//   on Affine in order to generate reports on its own sustainability and to provide those to target stakeholders (e.g. banks, insurers, buyers)
// While users can be a member of many organisations, organisations themselves are solitary in the Affine ecosystem - they only interact through
//   actions that are formal linkages provided through affine (e.g. requesting data from a supplier/producer, sending a report for viewing by a target stakeholder)

model Organisation {
  id String @id @unique @default(uuid())
  name String

  // Organisation type
  type OrgType[]

  // Org has many admins
  orgAdminID User[] @relation(name: "orgAdminId")

  // Org has many users
  userOrgId User[] @relation(name: "orgUserId")

  //organisation has modules to complete - no duplicates needed. Once completed one maps through to any module completion for that module
  orgModules Module[]

  //Organisation has results from module completions
  results Result[]

  // Org has many reports
  orgReportId Report[] @relation(name: "orgReportId")
}

// LEAVE FOR LATER
//model Department {
//  id String @unique @default(uuid())
//  name String
//
  //map to organisation
//  organisationId Organisation? @relation(fields: [id], references: [id])
//
  //map to user
//  userDepId User[]
//}

enum OrgType {
  SUPPLIER
  SUPERMARKET
  WHOLESALE
  FINANCE
  INSURANCE
  ASSURANCE_AND_CERTIFICATION
}

// Data collection modules - these are basic SurveyJS components for completion
model Module {
  // Identifying details
  id String @id @default(uuid())
  createdAt DateTime? @default(now())
  updatedAt DateTime? @default(now())

  // Model definition (this is a surveyJS survey definition)
  model String

  // Description and tags
  moduleName String
  moduleDescription String

  //map to collection
  collection Collection[]

  //map to user - optional and many to many
  orgModules  Organisation[]

  //module has many
  moduleResults Result[]
}

// A collection pulls together a set of modules to target a specific 'topic' (e.g. red meat carbon)
// This is like a 'tags' table that allows for simpler collating of modules as groups to send for completion
model Collection {
  id String @id @default(uuid())
  collectionName String
  description String

  // many to many relationship with modules (modules can be in many collections and vice versa)
  modules Module[]

}

model Result {
  id String @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())
  expiresAt DateTime? @default(now())

  //map to module
  resultModuleId Module @relation(fields: [id], references: [id], map: "moduleResults")

  //map to organisation
  orgId   Organisation @relation(fields: [id], references: [id], map: "orgModules")
}

model Report {
  id String @id @default(uuid())
  title String
  author User? @relation(fields: [id], references: [id], name: "AuthorId")
  orgAuthor Organisation @relation(fields: [id], references:[id], map: "orgReportId", name: "orgReportId")
  description String

  //Viewers of the report
  viewers User[] @relation(name: "reportsViewer")

}

// TOTP authorisations table
model Totp {
  id String   @id @default(uuid())
  createdAt DateTime? @default(now())
  hash String @unique
  attempts Int @default(0)
  active Boolean @default(true)
  expiresAt DateTime? @default(dbgenerated("now() + interval '15 minutes'"))
}
